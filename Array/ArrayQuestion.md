
Perfect üëç ‚Äî Arrays are **the foundation** of DSA, and Google (and other top tech companies) ask many array-based questions to test your logic, edge-case handling, and optimization skills.

Here‚Äôs a **categorized list of array questions** ‚Äî divided into **Easy, Medium, and Hard**, based on frequency and importance for interviews (especially Google, Amazon, Microsoft, etc.).

---

## üü¢ EASY LEVEL (Build Fundamentals)

These focus on understanding array traversal, counting, and simple operations.

| #  | Problem                                               | Concept Tested                       | Platform       |
| -- | ----------------------------------------------------- | ------------------------------------ | -------------- |
| 1  | **Find the Largest and Smallest Element in an Array** | Basic traversal                      | GFG            |
| 2  | **Reverse an Array**                                  | Two-pointer technique                | LeetCode / GFG |
| 3  | **Remove Duplicates from Sorted Array**               | Two pointers                         | LeetCode #26   |
| 4  | **Move Zeroes to the End**                            | Stable shifting, in-place operations | LeetCode #283  |
| 5  | **Check if Array is Sorted and Rotated**              | Observation, traversal               | LeetCode #1752 |
| 6  | **Find Missing Number**                               | Summation / XOR                      | LeetCode #268  |
| 7  | **Find Single Number**                                | XOR property                         | LeetCode #136  |
| 8  | **Intersection of Two Arrays**                        | Hashing                              | LeetCode #349  |
| 9  | **Union of Two Arrays**                               | HashSet usage                        | GFG            |
| 10 | **Best Time to Buy and Sell Stock I**                 | Min/max tracking                     | LeetCode #121  |

üß© *Practice Goal:* Understand traversal, memory usage, and learn Python list methods / Java ArrayList operations.

---

## üü° MEDIUM LEVEL (Core Interview Topics)

These require algorithmic thinking ‚Äî sorting, prefix sums, and two-pointer patterns.

| #  | Problem                                   | Concept Tested               | Platform      |
| -- | ----------------------------------------- | ---------------------------- | ------------- |
| 1  | **Two Sum**                               | Hashing, complement search   | LeetCode #1   |
| 2  | **3Sum**                                  | Sorting + Two pointers       | LeetCode #15  |
| 3  | **Subarray Sum Equals K**                 | Prefix sum + HashMap         | LeetCode #560 |
| 4  | **Maximum Subarray (Kadane‚Äôs Algorithm)** | Dynamic Programming          | LeetCode #53  |
| 5  | **Merge Intervals**                       | Sorting + merging logic      | LeetCode #56  |
| 6  | **Product of Array Except Self**          | Prefix/suffix product        | LeetCode #238 |
| 7  | **Sort Colors (Dutch National Flag)**     | In-place sorting, pointers   | LeetCode #75  |
| 8  | **Container With Most Water**             | Two-pointer optimization     | LeetCode #11  |
| 9  | **Majority Element**                      | Boyer-Moore Voting Algorithm | LeetCode #169 |
| 10 | **Find Duplicates in Array**              | Index marking or Hashing     | LeetCode #287 |

üß© *Practice Goal:* Learn to identify patterns ‚Äî sliding window, two pointers, hashing ‚Äî and optimize to O(n).

---

## üî¥ HARD LEVEL (Optimization & Patterns)

These test deep problem-solving skills and pattern recognition ‚Äî often seen in Google-level interviews.

| #  | Problem                                      | Concept Tested                         | Platform       |
| -- | -------------------------------------------- | -------------------------------------- | -------------- |
| 1  | **First Missing Positive**                   | Index marking, O(1) space              | LeetCode #41   |
| 2  | **Trapping Rain Water**                      | Two-pointer, prefix/suffix arrays      | LeetCode #42   |
| 3  | **Maximum Product Subarray**                 | Dynamic programming (min/max tracking) | LeetCode #152  |
| 4  | **Subarray with Maximum Average or Min Sum** | Kadane‚Äôs variants                      | LeetCode / GFG |
| 5  | **Longest Consecutive Sequence**             | HashSet, O(n) solution                 | LeetCode #128  |
| 6  | **Find Median of Two Sorted Arrays**         | Binary Search partitioning             | LeetCode #4    |
| 7  | **Minimum Number of Swaps to Sort**          | Graph cycles, sorting index mapping    | GFG            |
| 8  | **Kth Largest Element in an Array**          | Heap / Quickselect                     | LeetCode #215  |
| 9  | **Sliding Window Maximum**                   | Deque, monotonic queue                 | LeetCode #239  |
| 10 | **Shortest Unsorted Continuous Subarray**    | Sorting + bounds                       | LeetCode #581  |

üß© *Practice Goal:* Learn how to reduce O(n¬≤) ‚Üí O(n) with clever techniques, and practice dry-running edge cases.

---

## ‚öôÔ∏è Suggested Practice Flow

If you‚Äôre building a roadmap:

1. **Week 1:** Easy questions (10 total) ‚Üí Focus on fundamentals
2. **Week 2‚Äì3:** Medium problems (10‚Äì15) ‚Üí Learn patterns (two-pointer, prefix sum)
3. **Week 4‚Äì5:** Hard problems (10‚Äì15) ‚Üí Focus on optimization & edge cases

---

## üß† Bonus Tip

When practicing each array question:

1. Write **brute force** first (even if it‚Äôs O(n¬≤))
2. Then write the **optimized version**
3. Analyze **time and space complexity**
4. Note the **pattern** (e.g., ‚Äúsliding window,‚Äù ‚ÄúKadane,‚Äù ‚Äúprefix sum‚Äù)

---

Would you like me to turn these into a **weekly array study plan** (with links + goals + daily problem sets)?
It‚Äôll help you go from easy ‚Üí hard systematically in 3‚Äì4 weeks.
